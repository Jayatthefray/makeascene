{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { Camera } from 'expo-camera';\nimport * as MediaLibrary from 'expo-media-library';\nimport * as FileSystem from 'expo-file-system';\nimport { v4 as uuidv4 } from 'uuid';\nimport { deviceService } from \"../multiDevice/deviceService\";\nvar RecordingService = function () {\n  function RecordingService() {\n    _classCallCheck(this, RecordingService);\n    this.isInitialized = false;\n    this.cameraRef = null;\n    this.currentRecording = null;\n    this.recordingQuality = '1080p';\n    this.audioEnabled = true;\n    this.flashMode = Camera.Constants.FlashMode.off;\n    this.cameraType = Camera.Constants.Type.back;\n    this.stabilization = true;\n    this.focusMode = Camera.Constants.AutoFocus.on;\n    this.whiteBalance = Camera.Constants.WhiteBalance.auto;\n  }\n  return _createClass(RecordingService, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(function* () {\n        try {\n          var cameraPermission = yield Camera.requestCameraPermissionsAsync();\n          var audioPermission = yield Camera.requestMicrophonePermissionsAsync();\n          var mediaLibraryPermission = yield MediaLibrary.requestPermissionsAsync();\n          if (cameraPermission.status !== 'granted') {\n            throw new Error('Camera permission not granted');\n          }\n          if (audioPermission.status !== 'granted') {\n            console.warn('Audio permission not granted - recording without audio');\n            this.audioEnabled = false;\n          }\n          if (mediaLibraryPermission.status !== 'granted') {\n            console.warn('Media library permission not granted - manual save required');\n          }\n          this.isInitialized = true;\n          console.log('RecordingService initialized');\n          return {\n            success: true,\n            permissions: {\n              camera: cameraPermission.status,\n              audio: audioPermission.status,\n              mediaLibrary: mediaLibraryPermission.status\n            }\n          };\n        } catch (error) {\n          console.error('RecordingService initialization failed:', error);\n          return {\n            success: false,\n            error: error.message\n          };\n        }\n      });\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n      return initialize;\n    }()\n  }, {\n    key: \"setCameraRef\",\n    value: function setCameraRef(ref) {\n      this.cameraRef = ref;\n    }\n  }, {\n    key: \"configureRecording\",\n    value: function configureRecording() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$quality = options.quality,\n        quality = _options$quality === void 0 ? '1080p' : _options$quality,\n        _options$stabilizatio = options.stabilization,\n        stabilization = _options$stabilizatio === void 0 ? true : _options$stabilizatio,\n        _options$audio = options.audio,\n        audio = _options$audio === void 0 ? true : _options$audio,\n        _options$flashMode = options.flashMode,\n        flashMode = _options$flashMode === void 0 ? Camera.Constants.FlashMode.off : _options$flashMode,\n        _options$cameraType = options.cameraType,\n        cameraType = _options$cameraType === void 0 ? Camera.Constants.Type.back : _options$cameraType,\n        _options$focusMode = options.focusMode,\n        focusMode = _options$focusMode === void 0 ? Camera.Constants.AutoFocus.on : _options$focusMode,\n        _options$whiteBalance = options.whiteBalance,\n        whiteBalance = _options$whiteBalance === void 0 ? Camera.Constants.WhiteBalance.auto : _options$whiteBalance;\n      var qualityMap = {\n        '720p': Camera.Constants.VideoQuality['720p'],\n        '1080p': Camera.Constants.VideoQuality['1080p'],\n        '4K': Camera.Constants.VideoQuality['2160p']\n      };\n      this.recordingQuality = qualityMap[quality] || qualityMap['1080p'];\n      this.stabilization = stabilization;\n      this.audioEnabled = audio;\n      this.flashMode = flashMode;\n      this.cameraType = cameraType;\n      this.focusMode = focusMode;\n      this.whiteBalance = whiteBalance;\n      return {\n        quality: quality,\n        stabilization: stabilization,\n        audio: audio,\n        flashMode: flashMode,\n        cameraType: cameraType\n      };\n    }\n  }, {\n    key: \"startRecording\",\n    value: function () {\n      var _startRecording = _asyncToGenerator(function* () {\n        var shotData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!this.isInitialized || !this.cameraRef) {\n          throw new Error('Recording service not properly initialized');\n        }\n        try {\n          var recordingId = uuidv4();\n          var timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n          var filename = `scene_${shotData.shotNumber || 'unknown'}_take_${timestamp}`;\n          var recordingOptions = {\n            quality: this.recordingQuality,\n            stabilization: this.stabilization,\n            audio: this.audioEnabled,\n            mute: !this.audioEnabled,\n            maxDuration: shotData.maxDuration || 60,\n            maxFileSize: 100 * 1024 * 1024\n          };\n          var recordingPromise = this.cameraRef.recordAsync(recordingOptions);\n          this.currentRecording = {\n            id: recordingId,\n            filename: filename,\n            startTime: Date.now(),\n            shotData: shotData,\n            deviceId: deviceService.deviceId,\n            deviceRole: deviceService.deviceRole,\n            promise: recordingPromise\n          };\n          console.log('Recording started:', recordingId);\n          return {\n            success: true,\n            recordingId: recordingId,\n            filename: filename,\n            deviceRole: deviceService.deviceRole\n          };\n        } catch (error) {\n          console.error('Failed to start recording:', error);\n          return {\n            success: false,\n            error: error.message\n          };\n        }\n      });\n      function startRecording() {\n        return _startRecording.apply(this, arguments);\n      }\n      return startRecording;\n    }()\n  }, {\n    key: \"stopRecording\",\n    value: function () {\n      var _stopRecording = _asyncToGenerator(function* () {\n        if (!this.currentRecording) {\n          throw new Error('No active recording to stop');\n        }\n        try {\n          this.cameraRef.stopRecording();\n          var recordingResult = yield this.currentRecording.promise;\n          var endTime = Date.now();\n          var duration = (endTime - this.currentRecording.startTime) / 1000;\n          var fileInfo = yield FileSystem.getInfoAsync(recordingResult.uri);\n          var completedRecording = _objectSpread(_objectSpread({}, this.currentRecording), {}, {\n            endTime: endTime,\n            duration: duration,\n            uri: recordingResult.uri,\n            fileSize: fileInfo.size,\n            status: 'completed'\n          });\n          try {\n            yield MediaLibrary.saveToLibraryAsync(recordingResult.uri);\n            completedRecording.savedToLibrary = true;\n          } catch (error) {\n            console.warn('Could not save to media library:', error);\n            completedRecording.savedToLibrary = false;\n          }\n          this.currentRecording = null;\n          console.log('Recording completed:', completedRecording.id);\n          return {\n            success: true,\n            recording: completedRecording\n          };\n        } catch (error) {\n          console.error('Failed to stop recording:', error);\n          this.currentRecording = null;\n          return {\n            success: false,\n            error: error.message\n          };\n        }\n      });\n      function stopRecording() {\n        return _stopRecording.apply(this, arguments);\n      }\n      return stopRecording;\n    }()\n  }, {\n    key: \"startCoordinatedRecording\",\n    value: function () {\n      var _startCoordinatedRecording = _asyncToGenerator(function* (shotData) {\n        var _this = this;\n        var countdown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n        if (!deviceService.isInitialized) {\n          throw new Error('Device service not initialized for multi-device recording');\n        }\n        if (deviceService.deviceRole === 'primary') {\n          var coordinationResult = yield deviceService.startCoordinatedRecording(countdown);\n          setTimeout(_asyncToGenerator(function* () {\n            yield _this.startRecording(_objectSpread(_objectSpread({}, shotData), {}, {\n              isCoordinated: true,\n              recordingId: coordinationResult.recordingId\n            }));\n          }), countdown * 1000);\n          return coordinationResult;\n        } else {\n          return this.waitForCoordinationSignal();\n        }\n      });\n      function startCoordinatedRecording(_x) {\n        return _startCoordinatedRecording.apply(this, arguments);\n      }\n      return startCoordinatedRecording;\n    }()\n  }, {\n    key: \"waitForCoordinationSignal\",\n    value: function () {\n      var _waitForCoordinationSignal = _asyncToGenerator(function* () {\n        var _this2 = this;\n        return new Promise(function (resolve) {\n          var handleCoordination = function handleCoordination(data) {\n            if (data.command === 'start_recording') {\n              var delay = data.startTimestamp - Date.now();\n              setTimeout(_asyncToGenerator(function* () {\n                yield _this2.startRecording({\n                  isCoordinated: true,\n                  recordingId: data.recordingId,\n                  role: deviceService.deviceRole\n                });\n              }), Math.max(0, delay));\n              resolve({\n                success: true,\n                recordingId: data.recordingId,\n                role: deviceService.deviceRole\n              });\n            }\n          };\n          deviceService.onCoordinationSignal = handleCoordination;\n        });\n      });\n      function waitForCoordinationSignal() {\n        return _waitForCoordinationSignal.apply(this, arguments);\n      }\n      return waitForCoordinationSignal;\n    }()\n  }, {\n    key: \"startAIGuidedRecording\",\n    value: function () {\n      var _startAIGuidedRecording = _asyncToGenerator(function* (shotData, storyboardSketch) {\n        var recordingOptions = _objectSpread(_objectSpread({}, shotData), {}, {\n          hasAIGuidance: true,\n          storyboardSketch: storyboardSketch,\n          aiInstructions: this.generateAIInstructions(shotData)\n        });\n        return this.startRecording(recordingOptions);\n      });\n      function startAIGuidedRecording(_x2, _x3) {\n        return _startAIGuidedRecording.apply(this, arguments);\n      }\n      return startAIGuidedRecording;\n    }()\n  }, {\n    key: \"generateAIInstructions\",\n    value: function generateAIInstructions(shotData) {\n      var shotType = shotData.shotType,\n        description = shotData.description,\n        cameraPosition = shotData.cameraPosition,\n        actorPositions = shotData.actorPositions;\n      var instructions = {\n        cameraSetup: this.getCameraSetupInstructions(shotType),\n        positioning: this.getPositioningInstructions(cameraPosition, actorPositions),\n        movement: this.getMovementInstructions(shotType),\n        timing: this.getTimingInstructions(shotData),\n        tips: this.getProTips(shotType)\n      };\n      return instructions;\n    }\n  }, {\n    key: \"getCameraSetupInstructions\",\n    value: function getCameraSetupInstructions(shotType) {\n      var setups = {\n        'selfie': 'Use front camera, hold at arm\\'s length, ensure face is centered',\n        'single_handheld': 'Use back camera, hold steady with both hands, maintain eye level',\n        'two_shot_handheld': 'Frame both subjects, leave headroom, use rule of thirds',\n        'group_static': 'Use tripod if available, wide angle, ensure everyone is visible',\n        'moving_tracking': 'Follow subject smoothly, keep steady pace, anticipate movement',\n        'cinematic_sequence': 'Plan camera movement, use multiple angles, maintain continuity'\n      };\n      return setups[shotType] || 'Follow standard filming practices';\n    }\n  }, {\n    key: \"getPositioningInstructions\",\n    value: function getPositioningInstructions(cameraPosition, actorPositions) {\n      return {\n        camera: cameraPosition || 'Eye level, stable position',\n        actors: actorPositions || 'Natural, well-lit positions',\n        lighting: 'Avoid backlighting, use natural light when possible',\n        background: 'Check for distracting elements, keep it simple'\n      };\n    }\n  }, {\n    key: \"getMovementInstructions\",\n    value: function getMovementInstructions(shotType) {\n      var movements = {\n        'moving_tracking': 'Smooth follow movement, maintain consistent distance',\n        'cinematic_sequence': 'Planned camera movement, coordinate with actors',\n        'static': 'Keep camera steady, minimal movement'\n      };\n      return movements[shotType] || 'Keep camera steady';\n    }\n  }, {\n    key: \"getTimingInstructions\",\n    value: function getTimingInstructions(shotData) {\n      var estimatedDuration = shotData.estimatedDuration,\n        dialogue = shotData.dialogue;\n      return {\n        duration: `Aim for ${estimatedDuration || 30} seconds`,\n        pacing: dialogue ? 'Allow time for dialogue delivery' : 'Maintain steady pacing',\n        action: 'Start recording before action, continue after completion'\n      };\n    }\n  }, {\n    key: \"getProTips\",\n    value: function getProTips(shotType) {\n      var tips = {\n        'selfie': ['Keep phone steady', 'Good lighting on face', 'Practice expression'],\n        'single_handheld': ['Use both hands', 'Breathe steadily', 'Focus on subject'],\n        'two_shot_handheld': ['Leave room for both subjects', 'Check framing often', 'Maintain balance'],\n        'group_static': ['Count subjects before recording', 'Use tripod if possible', 'Wide shot'],\n        'moving_tracking': ['Practice movement first', 'Smooth motion', 'Keep subject in frame'],\n        'cinematic_sequence': ['Plan shots in advance', 'Multiple angles', 'Maintain continuity']\n      };\n      return tips[shotType] || ['Keep camera steady', 'Good lighting', 'Practice first'];\n    }\n  }, {\n    key: \"assessRecordingQuality\",\n    value: function () {\n      var _assessRecordingQuality = _asyncToGenerator(function* (recordingUri) {\n        try {\n          var fileInfo = yield FileSystem.getInfoAsync(recordingUri);\n          var qualityScore = 100;\n          var issues = [];\n          if (fileInfo.size < 1024 * 1024) {\n            qualityScore -= 20;\n            issues.push('File size very small - possible recording issue');\n          }\n          var stabilityScore = Math.floor(Math.random() * 40) + 60;\n          var audioQualityScore = this.audioEnabled ? Math.floor(Math.random() * 30) + 70 : 0;\n          var framingScore = Math.floor(Math.random() * 30) + 70;\n          qualityScore = Math.floor((stabilityScore + audioQualityScore + framingScore) / 3);\n          if (stabilityScore < 70) issues.push('Camera stability could be improved');\n          if (audioQualityScore < 70 && this.audioEnabled) issues.push('Audio quality needs improvement');\n          if (framingScore < 70) issues.push('Framing and composition could be better');\n          return {\n            overallScore: qualityScore,\n            stabilityScore: stabilityScore,\n            audioQualityScore: audioQualityScore,\n            framingScore: framingScore,\n            issues: issues,\n            fileSize: fileInfo.size,\n            recommendations: this.getQualityRecommendations(qualityScore, issues)\n          };\n        } catch (error) {\n          console.error('Quality assessment failed:', error);\n          return {\n            overallScore: 0,\n            error: error.message\n          };\n        }\n      });\n      function assessRecordingQuality(_x4) {\n        return _assessRecordingQuality.apply(this, arguments);\n      }\n      return assessRecordingQuality;\n    }()\n  }, {\n    key: \"getQualityRecommendations\",\n    value: function getQualityRecommendations(score, issues) {\n      if (score >= 90) {\n        return ['Excellent recording! Ready for final scene.'];\n      } else if (score >= 75) {\n        return ['Good quality. Consider minor improvements.'].concat(_toConsumableArray(issues));\n      } else if (score >= 60) {\n        return ['Acceptable quality but could be improved.'].concat(_toConsumableArray(issues), ['Consider retaking for best results.']);\n      } else {\n        return ['Quality needs significant improvement.'].concat(_toConsumableArray(issues), ['Recommend retaking this shot.']);\n      }\n    }\n  }, {\n    key: \"switchCamera\",\n    value: function () {\n      var _switchCamera = _asyncToGenerator(function* () {\n        this.cameraType = this.cameraType === Camera.Constants.Type.back ? Camera.Constants.Type.front : Camera.Constants.Type.back;\n        return this.cameraType;\n      });\n      function switchCamera() {\n        return _switchCamera.apply(this, arguments);\n      }\n      return switchCamera;\n    }()\n  }, {\n    key: \"toggleFlash\",\n    value: function () {\n      var _toggleFlash = _asyncToGenerator(function* () {\n        var flashModes = [Camera.Constants.FlashMode.off, Camera.Constants.FlashMode.on, Camera.Constants.FlashMode.auto];\n        var currentIndex = flashModes.indexOf(this.flashMode);\n        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];\n        return this.flashMode;\n      });\n      function toggleFlash() {\n        return _toggleFlash.apply(this, arguments);\n      }\n      return toggleFlash;\n    }()\n  }, {\n    key: \"getRecordingStatus\",\n    value: function getRecordingStatus() {\n      if (!this.currentRecording) {\n        return {\n          isRecording: false\n        };\n      }\n      var elapsed = (Date.now() - this.currentRecording.startTime) / 1000;\n      return {\n        isRecording: true,\n        recordingId: this.currentRecording.id,\n        elapsed: elapsed,\n        deviceRole: this.currentRecording.deviceRole,\n        filename: this.currentRecording.filename\n      };\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.currentRecording) {\n        this.stopRecording().catch(console.error);\n      }\n      this.cameraRef = null;\n      this.isInitialized = false;\n      console.log('RecordingService cleaned up');\n    }\n  }]);\n}();\nexport var recordingService = new RecordingService();\nexport default RecordingService;","map":{"version":3,"names":["Camera","MediaLibrary","FileSystem","v4","uuidv4","deviceService","RecordingService","_classCallCheck","isInitialized","cameraRef","currentRecording","recordingQuality","audioEnabled","flashMode","Constants","FlashMode","off","cameraType","Type","back","stabilization","focusMode","AutoFocus","on","whiteBalance","WhiteBalance","auto","_createClass","key","value","_initialize","_asyncToGenerator","cameraPermission","requestCameraPermissionsAsync","audioPermission","requestMicrophonePermissionsAsync","mediaLibraryPermission","requestPermissionsAsync","status","Error","console","warn","log","success","permissions","camera","audio","mediaLibrary","error","message","initialize","apply","arguments","setCameraRef","ref","configureRecording","options","length","undefined","_options$quality","quality","_options$stabilizatio","_options$audio","_options$flashMode","_options$cameraType","_options$focusMode","_options$whiteBalance","qualityMap","VideoQuality","_startRecording","shotData","recordingId","timestamp","Date","toISOString","replace","filename","shotNumber","recordingOptions","mute","maxDuration","maxFileSize","recordingPromise","recordAsync","id","startTime","now","deviceId","deviceRole","promise","startRecording","_stopRecording","stopRecording","recordingResult","endTime","duration","fileInfo","getInfoAsync","uri","completedRecording","_objectSpread","fileSize","size","saveToLibraryAsync","savedToLibrary","recording","_startCoordinatedRecording","_this","countdown","coordinationResult","startCoordinatedRecording","setTimeout","isCoordinated","waitForCoordinationSignal","_x","_waitForCoordinationSignal","_this2","Promise","resolve","handleCoordination","data","command","delay","startTimestamp","role","Math","max","onCoordinationSignal","_startAIGuidedRecording","storyboardSketch","hasAIGuidance","aiInstructions","generateAIInstructions","startAIGuidedRecording","_x2","_x3","shotType","description","cameraPosition","actorPositions","instructions","cameraSetup","getCameraSetupInstructions","positioning","getPositioningInstructions","movement","getMovementInstructions","timing","getTimingInstructions","tips","getProTips","setups","actors","lighting","background","movements","estimatedDuration","dialogue","pacing","action","_assessRecordingQuality","recordingUri","qualityScore","issues","push","stabilityScore","floor","random","audioQualityScore","framingScore","overallScore","recommendations","getQualityRecommendations","assessRecordingQuality","_x4","score","concat","_toConsumableArray","_switchCamera","front","switchCamera","_toggleFlash","flashModes","currentIndex","indexOf","toggleFlash","getRecordingStatus","isRecording","elapsed","cleanup","catch","recordingService"],"sources":["/workspace/MakeAScene/lib/recording/recordingService.js"],"sourcesContent":["import { Camera } from 'expo-camera';\nimport * as MediaLibrary from 'expo-media-library';\nimport * as FileSystem from 'expo-file-system';\nimport { v4 as uuidv4 } from 'uuid';\nimport { deviceService } from '../multiDevice/deviceService';\n\n// Enhanced Recording System (Week 4-6 Feature)\nclass RecordingService {\n  constructor() {\n    this.isInitialized = false;\n    this.cameraRef = null;\n    this.currentRecording = null;\n    this.recordingQuality = '1080p';\n    this.audioEnabled = true;\n    this.flashMode = Camera.Constants.FlashMode.off;\n    this.cameraType = Camera.Constants.Type.back;\n    this.stabilization = true;\n    this.focusMode = Camera.Constants.AutoFocus.on;\n    this.whiteBalance = Camera.Constants.WhiteBalance.auto;\n  }\n\n  // Initialize recording service\n  async initialize() {\n    try {\n      // Request camera permissions\n      const cameraPermission = await Camera.requestCameraPermissionsAsync();\n      const audioPermission = await Camera.requestMicrophonePermissionsAsync();\n      const mediaLibraryPermission = await MediaLibrary.requestPermissionsAsync();\n\n      if (cameraPermission.status !== 'granted') {\n        throw new Error('Camera permission not granted');\n      }\n\n      if (audioPermission.status !== 'granted') {\n        console.warn('Audio permission not granted - recording without audio');\n        this.audioEnabled = false;\n      }\n\n      if (mediaLibraryPermission.status !== 'granted') {\n        console.warn('Media library permission not granted - manual save required');\n      }\n\n      this.isInitialized = true;\n      console.log('RecordingService initialized');\n\n      return { \n        success: true, \n        permissions: {\n          camera: cameraPermission.status,\n          audio: audioPermission.status,\n          mediaLibrary: mediaLibraryPermission.status\n        }\n      };\n    } catch (error) {\n      console.error('RecordingService initialization failed:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  // Set camera reference from component\n  setCameraRef(ref) {\n    this.cameraRef = ref;\n  }\n\n  // Professional Recording Configuration\n  configureRecording(options = {}) {\n    const {\n      quality = '1080p',\n      stabilization = true,\n      audio = true,\n      flashMode = Camera.Constants.FlashMode.off,\n      cameraType = Camera.Constants.Type.back,\n      focusMode = Camera.Constants.AutoFocus.on,\n      whiteBalance = Camera.Constants.WhiteBalance.auto\n    } = options;\n\n    // Quality mapping to Expo Camera constants\n    const qualityMap = {\n      '720p': Camera.Constants.VideoQuality['720p'],\n      '1080p': Camera.Constants.VideoQuality['1080p'],\n      '4K': Camera.Constants.VideoQuality['2160p'] // 4K\n    };\n\n    this.recordingQuality = qualityMap[quality] || qualityMap['1080p'];\n    this.stabilization = stabilization;\n    this.audioEnabled = audio;\n    this.flashMode = flashMode;\n    this.cameraType = cameraType;\n    this.focusMode = focusMode;\n    this.whiteBalance = whiteBalance;\n\n    return {\n      quality,\n      stabilization,\n      audio,\n      flashMode,\n      cameraType\n    };\n  }\n\n  // Start Single Device Recording\n  async startRecording(shotData = {}) {\n    if (!this.isInitialized || !this.cameraRef) {\n      throw new Error('Recording service not properly initialized');\n    }\n\n    try {\n      const recordingId = uuidv4();\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const filename = `scene_${shotData.shotNumber || 'unknown'}_take_${timestamp}`;\n\n      const recordingOptions = {\n        quality: this.recordingQuality,\n        stabilization: this.stabilization,\n        audio: this.audioEnabled,\n        mute: !this.audioEnabled,\n        maxDuration: shotData.maxDuration || 60, // seconds\n        maxFileSize: 100 * 1024 * 1024, // 100MB\n      };\n\n      // Start recording\n      const recordingPromise = this.cameraRef.recordAsync(recordingOptions);\n      \n      this.currentRecording = {\n        id: recordingId,\n        filename,\n        startTime: Date.now(),\n        shotData,\n        deviceId: deviceService.deviceId,\n        deviceRole: deviceService.deviceRole,\n        promise: recordingPromise\n      };\n\n      console.log('Recording started:', recordingId);\n\n      return {\n        success: true,\n        recordingId,\n        filename,\n        deviceRole: deviceService.deviceRole\n      };\n    } catch (error) {\n      console.error('Failed to start recording:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  // Stop Single Device Recording\n  async stopRecording() {\n    if (!this.currentRecording) {\n      throw new Error('No active recording to stop');\n    }\n\n    try {\n      // Stop the recording\n      this.cameraRef.stopRecording();\n      \n      // Wait for the recording to complete\n      const recordingResult = await this.currentRecording.promise;\n      \n      const endTime = Date.now();\n      const duration = (endTime - this.currentRecording.startTime) / 1000; // seconds\n\n      // Get file info\n      const fileInfo = await FileSystem.getInfoAsync(recordingResult.uri);\n\n      const completedRecording = {\n        ...this.currentRecording,\n        endTime,\n        duration,\n        uri: recordingResult.uri,\n        fileSize: fileInfo.size,\n        status: 'completed'\n      };\n\n      // Save to media library if permissions granted\n      try {\n        await MediaLibrary.saveToLibraryAsync(recordingResult.uri);\n        completedRecording.savedToLibrary = true;\n      } catch (error) {\n        console.warn('Could not save to media library:', error);\n        completedRecording.savedToLibrary = false;\n      }\n\n      // Clear current recording\n      this.currentRecording = null;\n\n      console.log('Recording completed:', completedRecording.id);\n\n      return {\n        success: true,\n        recording: completedRecording\n      };\n    } catch (error) {\n      console.error('Failed to stop recording:', error);\n      this.currentRecording = null;\n      return { success: false, error: error.message };\n    }\n  }\n\n  // Multi-Device Coordinated Recording\n  async startCoordinatedRecording(shotData, countdown = 3) {\n    if (!deviceService.isInitialized) {\n      throw new Error('Device service not initialized for multi-device recording');\n    }\n\n    // Only primary device can initiate coordinated recording\n    if (deviceService.deviceRole === 'primary') {\n      // Start coordinated countdown across all devices\n      const coordinationResult = await deviceService.startCoordinatedRecording(countdown);\n      \n      // Start local recording after countdown\n      setTimeout(async () => {\n        await this.startRecording({\n          ...shotData,\n          isCoordinated: true,\n          recordingId: coordinationResult.recordingId\n        });\n      }, countdown * 1000);\n\n      return coordinationResult;\n    } else {\n      // Secondary devices wait for coordination signal\n      return this.waitForCoordinationSignal();\n    }\n  }\n\n  // Wait for coordination signal (secondary devices)\n  async waitForCoordinationSignal() {\n    return new Promise((resolve) => {\n      const handleCoordination = (data) => {\n        if (data.command === 'start_recording') {\n          const delay = data.startTimestamp - Date.now();\n          \n          setTimeout(async () => {\n            await this.startRecording({\n              isCoordinated: true,\n              recordingId: data.recordingId,\n              role: deviceService.deviceRole\n            });\n          }, Math.max(0, delay));\n\n          resolve({\n            success: true,\n            recordingId: data.recordingId,\n            role: deviceService.deviceRole\n          });\n        }\n      };\n\n      // Listen for coordination signals\n      // In real implementation, this would be a WebRTC data channel listener\n      deviceService.onCoordinationSignal = handleCoordination;\n    });\n  }\n\n  // AI-Guided Recording with Overlay\n  async startAIGuidedRecording(shotData, storyboardSketch) {\n    const recordingOptions = {\n      ...shotData,\n      hasAIGuidance: true,\n      storyboardSketch,\n      aiInstructions: this.generateAIInstructions(shotData)\n    };\n\n    return this.startRecording(recordingOptions);\n  }\n\n  // Generate AI instructions for filming\n  generateAIInstructions(shotData) {\n    const { shotType, description, cameraPosition, actorPositions } = shotData;\n\n    const instructions = {\n      cameraSetup: this.getCameraSetupInstructions(shotType),\n      positioning: this.getPositioningInstructions(cameraPosition, actorPositions),\n      movement: this.getMovementInstructions(shotType),\n      timing: this.getTimingInstructions(shotData),\n      tips: this.getProTips(shotType)\n    };\n\n    return instructions;\n  }\n\n  // Camera setup instructions based on shot type\n  getCameraSetupInstructions(shotType) {\n    const setups = {\n      'selfie': 'Use front camera, hold at arm\\'s length, ensure face is centered',\n      'single_handheld': 'Use back camera, hold steady with both hands, maintain eye level',\n      'two_shot_handheld': 'Frame both subjects, leave headroom, use rule of thirds',\n      'group_static': 'Use tripod if available, wide angle, ensure everyone is visible',\n      'moving_tracking': 'Follow subject smoothly, keep steady pace, anticipate movement',\n      'cinematic_sequence': 'Plan camera movement, use multiple angles, maintain continuity'\n    };\n\n    return setups[shotType] || 'Follow standard filming practices';\n  }\n\n  // Positioning instructions\n  getPositioningInstructions(cameraPosition, actorPositions) {\n    return {\n      camera: cameraPosition || 'Eye level, stable position',\n      actors: actorPositions || 'Natural, well-lit positions',\n      lighting: 'Avoid backlighting, use natural light when possible',\n      background: 'Check for distracting elements, keep it simple'\n    };\n  }\n\n  // Movement instructions\n  getMovementInstructions(shotType) {\n    const movements = {\n      'moving_tracking': 'Smooth follow movement, maintain consistent distance',\n      'cinematic_sequence': 'Planned camera movement, coordinate with actors',\n      'static': 'Keep camera steady, minimal movement'\n    };\n\n    return movements[shotType] || 'Keep camera steady';\n  }\n\n  // Timing instructions\n  getTimingInstructions(shotData) {\n    const { estimatedDuration, dialogue } = shotData;\n    \n    return {\n      duration: `Aim for ${estimatedDuration || 30} seconds`,\n      pacing: dialogue ? 'Allow time for dialogue delivery' : 'Maintain steady pacing',\n      action: 'Start recording before action, continue after completion'\n    };\n  }\n\n  // Professional tips based on shot type\n  getProTips(shotType) {\n    const tips = {\n      'selfie': ['Keep phone steady', 'Good lighting on face', 'Practice expression'],\n      'single_handheld': ['Use both hands', 'Breathe steadily', 'Focus on subject'],\n      'two_shot_handheld': ['Leave room for both subjects', 'Check framing often', 'Maintain balance'],\n      'group_static': ['Count subjects before recording', 'Use tripod if possible', 'Wide shot'],\n      'moving_tracking': ['Practice movement first', 'Smooth motion', 'Keep subject in frame'],\n      'cinematic_sequence': ['Plan shots in advance', 'Multiple angles', 'Maintain continuity']\n    };\n\n    return tips[shotType] || ['Keep camera steady', 'Good lighting', 'Practice first'];\n  }\n\n  // Quality Assessment\n  async assessRecordingQuality(recordingUri) {\n    try {\n      // Basic file info assessment\n      const fileInfo = await FileSystem.getInfoAsync(recordingUri);\n      \n      let qualityScore = 100;\n      let issues = [];\n\n      // File size check (too small might indicate problems)\n      if (fileInfo.size < 1024 * 1024) { // Less than 1MB\n        qualityScore -= 20;\n        issues.push('File size very small - possible recording issue');\n      }\n\n      // Duration check would require video analysis library\n      // For now, we'll simulate quality scoring\n      const stabilityScore = Math.floor(Math.random() * 40) + 60; // 60-100\n      const audioQualityScore = this.audioEnabled ? Math.floor(Math.random() * 30) + 70 : 0;\n      const framingScore = Math.floor(Math.random() * 30) + 70;\n\n      qualityScore = Math.floor((stabilityScore + audioQualityScore + framingScore) / 3);\n\n      if (stabilityScore < 70) issues.push('Camera stability could be improved');\n      if (audioQualityScore < 70 && this.audioEnabled) issues.push('Audio quality needs improvement');\n      if (framingScore < 70) issues.push('Framing and composition could be better');\n\n      return {\n        overallScore: qualityScore,\n        stabilityScore,\n        audioQualityScore,\n        framingScore,\n        issues,\n        fileSize: fileInfo.size,\n        recommendations: this.getQualityRecommendations(qualityScore, issues)\n      };\n    } catch (error) {\n      console.error('Quality assessment failed:', error);\n      return {\n        overallScore: 0,\n        error: error.message\n      };\n    }\n  }\n\n  // Quality improvement recommendations\n  getQualityRecommendations(score, issues) {\n    if (score >= 90) {\n      return ['Excellent recording! Ready for final scene.'];\n    } else if (score >= 75) {\n      return ['Good quality. Consider minor improvements.', ...issues];\n    } else if (score >= 60) {\n      return ['Acceptable quality but could be improved.', ...issues, 'Consider retaking for best results.'];\n    } else {\n      return ['Quality needs significant improvement.', ...issues, 'Recommend retaking this shot.'];\n    }\n  }\n\n  // Camera Control Methods\n  async switchCamera() {\n    this.cameraType = this.cameraType === Camera.Constants.Type.back \n      ? Camera.Constants.Type.front \n      : Camera.Constants.Type.back;\n    \n    return this.cameraType;\n  }\n\n  async toggleFlash() {\n    const flashModes = [\n      Camera.Constants.FlashMode.off,\n      Camera.Constants.FlashMode.on,\n      Camera.Constants.FlashMode.auto\n    ];\n    \n    const currentIndex = flashModes.indexOf(this.flashMode);\n    this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];\n    \n    return this.flashMode;\n  }\n\n  // Get current recording status\n  getRecordingStatus() {\n    if (!this.currentRecording) {\n      return { isRecording: false };\n    }\n\n    const elapsed = (Date.now() - this.currentRecording.startTime) / 1000;\n    \n    return {\n      isRecording: true,\n      recordingId: this.currentRecording.id,\n      elapsed,\n      deviceRole: this.currentRecording.deviceRole,\n      filename: this.currentRecording.filename\n    };\n  }\n\n  // Cleanup resources\n  cleanup() {\n    if (this.currentRecording) {\n      this.stopRecording().catch(console.error);\n    }\n    \n    this.cameraRef = null;\n    this.isInitialized = false;\n    \n    console.log('RecordingService cleaned up');\n  }\n}\n\n// Export singleton instance\nexport const recordingService = new RecordingService();\n\nexport default RecordingService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}